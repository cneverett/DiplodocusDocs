[{"id":3,"pagetitle":"Overview","title":"BoltzmannCollisionIntegral.jl","ref":"/boltzmanncollisionintegral/stable/#BoltzmannCollisionIntegral.jl","content":" BoltzmannCollisionIntegral.jl BoltzmannCollisionIntegral.jl  is a package for the evaluation of the Boltzmann collision integral for binary interactions of arbitrary momentum and anisotropic particle distributions using a method of momentum discretisation and Monte-Carlo integration.  The code now also includes a module for the evaluation of synchrotron emissions, with details found in  Synchrotron Radiation . The evaluation of the collision integral is of great use when studying kinetic system. The evolution of particle distributions  $f(x^\\mu,\\boldsymbol{p})$  within such a system is dictated by the collisional relativistic Boltzmann equation ( Everett+Cotter 2024 ): \\[p^\\nu\\partial_\\nu f(x^\\mu,\\boldsymbol{p})+\\partial_{p^\\nu}\\left(F^\\nu f(x^\\mu,\\boldsymbol{p})\\right)=C(x^\\mu,\\boldsymbol{p}),\\] where  $p^\\mu=(p^0,\\boldsymbol{p})$  is the 4-Momentum and  $C(x^\\mu,\\boldsymbol{p})$  is the collision integral at a particular point in spacetime  $x^\\mu$ . From here we shall neglect the terms involving advection in space and advection on momentum-space (external forcing), as such the dependence on  $x^\\mu$  is also dropped. What is left can be written as  \\[    \\partial_t f(\\boldsymbol{p}) = \\frac{1}{p^0}C(\\boldsymbol{p})\\] The collision integral for a particular particle  $3$  in the interaction  $12\\rightleftharpoons34$  is given by  \\[    C(\\boldsymbol{p}_3)=\\int\\frac{\\mathrm{d}^3\\boldsymbol{p}_1}{p_1^0}\\frac{\\mathrm{d}^3\\boldsymbol{p}_2}{p_2^0}\\frac{\\mathrm{d}^3\\boldsymbol{p}_4}{p_4^0}\\left[\\frac{f(\\boldsymbol{p}_1)f(\\boldsymbol{p}_2)}{1+\\delta_{12}}W(p_1^\\mu,p_2^\\mu|p_3^\\mu,p_4^\\mu)- \\frac{f(\\boldsymbol{p}_3)f(\\boldsymbol{p}_4)}{1+\\delta_{12}}W(p_3^\\mu,p_4^\\mu|p_1^\\mu,p_2^\\mu)\\right],\\] with the transition rate  $W$  being given by: \\[W(p_1^\\mu,p_2^\\mu|p_3^\\mu,p_4^\\mu)=\\frac{sp_{\\text{in}}^{*2}}{\\pi}\\frac{\\mathrm{d}\\sigma_{12|34}}{\\mathrm{d}t}(s,t)\\delta^{(4)}(p_1^\\mu+p_2^\\mu-p_3^\\mu-p_4^\\mu),\\] and  $\\frac{\\mathrm{d}\\sigma_{12|34}}{\\mathrm{d}t}(s,t)$  is the Lorentz invariant differential cross section of the forward reaction  $12\\to34$ . The Boltzmann equation can then be discretised in momentum space by integrating over a discrete volume element  $\\Delta^3\\boldsymbol{p}_3$  to yield:  \\[\\int_{\\Delta^3\\boldsymbol{p}_3}\\frac{\\mathrm{d}^3\\boldsymbol{p}_3}{p_3^0}p_3^\\mu\\partial_\\mu f(x^\\mu,\\boldsymbol{p}_3)=\\int_{\\Delta^3\\boldsymbol{p}_3}\\mathrm{d}^3\\boldsymbol{p}_3~S_{spe}(x^\\mu,\\boldsymbol{p}_3)-T_{spe}(x^\\mu,\\boldsymbol{p}_3),\\] where the collision integral has been split into two parts, an emission spectrum \\[S_{\\text{spe}}(\\boldsymbol{p}_3)=\\frac{1}{1+\\delta_{12}}\\frac{1}{p^0_3}\\int\\frac{\\mathrm{d}^3\\boldsymbol{p}_1}{p_1^0}\\frac{\\mathrm{d}^3\\boldsymbol{p}_2}{p_2^0}\\frac{\\mathrm{d}^3\\boldsymbol{p}_4}{p_4^0}f(\\boldsymbol{p}_1)f(\\boldsymbol{p}_2)W(p_1^\\mu,p_2^\\mu|p_3^\\mu,p_4^\\mu),\\] math dictating the rate of gain of particles of a specific type at a specific momentum from a binary interaction, and an absorption spectrum  \\[T_{\\text{spe}}(\\boldsymbol{p}_3)=\\frac{1}{1+\\delta_{12}}\\frac{1}{p^0_3}\\int\\frac{\\mathrm{d}^3\\boldsymbol{p}_1}{p_1^0}\\frac{\\mathrm{d}^3\\boldsymbol{p}_2}{p_2^0}\\frac{\\mathrm{d}^3\\boldsymbol{p}_4}{p_4^0} f(\\boldsymbol{p}_3)f(\\boldsymbol{p}_4)W(p_3^\\mu,p_4^\\mu|p_1^\\mu,p_2^\\mu),\\] dictating the rate of loss of particles of a specific type at a specific momentum from the same interaction."},{"id":4,"pagetitle":"Overview","title":"Assumptions","ref":"/boltzmanncollisionintegral/stable/#Assumptions","content":" Assumptions In order to enable the evaluation of the emission and absorption terms, we make the following set of assumptions (dropping dependence on space-time for notational simplicity):   The system is axisymmetric in momentum space coordinates i.e. only dependant on  $p=|\\boldsymbol{p}|$  and the cosine of the angle to the axis of symmetry ( $\\hat{z}$ )  $u$  where  $\\hat{z}\\cdot\\boldsymbol{p}=p\\cos\\theta=pu$ The distribution functions are redefined in an axisymmetric form i.e.  $f(\\boldsymbol{p})\\equiv\\frac{f(p,u)}{2\\pi p^2}$ . This is done such that a single particle is described by the distribution  $f(p,u)=\\delta(p-p_i)\\delta(u-u_i)$ . The axisymmetric distribution functions are averaged over phase space intervals  $\\Delta p\\Delta u$ , to generate discrete values i.e.  $f(t,p_i, u_j)=\\frac{1}{\\Delta p_i\\Delta u_j}\\int_{\\Delta p_i\\Delta u_j} \\mathrm{d}p \\mathrm{d} u~f(p, u)$ , such that they act as if they are constant over that interval of phase space.   Particle masses, momenta and energies are normalised by a factor of the rest mass of the electron  $m_\\text{Ele}$  and the speed of light  $c=1$ ."},{"id":5,"pagetitle":"Overview","title":"Discrete Form of the Boltzmann Equation","ref":"/boltzmanncollisionintegral/stable/#Discrete-Form-of-the-Boltzmann-Equation","content":" Discrete Form of the Boltzmann Equation Following the assumptions laid out in the previous section. The axisymmetric, momentum-discrete Boltzmann equation is given by (remember the neglect of space and momentum-space advection terms) \\[\\partial_t f_{3,ij}=f_{1,kl}f_{2,mn}S_{12|34,ijklmn}-f_{3,ij}f_{4,kl}T_{34|12,ijkl}\\] The discrete emission spectrum term is a 6D array, given by \\[f_{1,kl}f_{2,mn}S_{12|34,ijklmn}=f(p_{1,k}, u_{1,l})f(p_{2,m}, u_{2,n})\\frac{\\Delta p_{1,k}\\Delta  u_{1,l}\\Delta p_{2,m}\\Delta  u_{2,n}}{\\Delta p_{3,i}}\\frac{1}{N}\\sum^{N}_{a=1}\\left[S_{val}\\right](\\{\\boldsymbol{p}_1,\\boldsymbol{p}_2,\\boldsymbol{p}_3\\}_a), \\] with  \\[S_{val}=\\frac{1}{1+\\delta_{12}}\\sum_\\pm\\frac{2p_\\pm^2\\mathcal{F}_{12}^2}{p_1^0p_2^0}\\frac{\\mathrm{d}\\sigma_{12|34}}{\\mathrm{d}t}(s,t_\\pm)\\frac{1}{p_1^0p_\\pm-p_\\pm^0p_1\\cos\\Theta_{\\pm1}+p_2^0p_\\pm-p_\\pm^0p_2\\cos\\Theta_{\\pm2}},\\] where  $p_{\\pm}$  are the two roots of  $(s+t-m_3^2-m_2^2-2p^ u_1p_{4 u})$ .  The discrete absorption term is a 4D Array, given by \\[f_{3,ij}f_{4,kl}T_{34|12,ijkl}=f(p_{3,i}, u_{3,j})f(p_{4,k}, u_{4,l})\\Delta\\boldsymbol{p}_{4,k}\\Delta u_{4,l}\\frac{1}{N}\\sum^{N}_{a=1}\\left[T_{val}\\right](\\{\\boldsymbol{p}_3,\\boldsymbol{p}_4\\}_a),\\] with \\[T_{val}=\\frac{1}{1+\\delta_{12}}\\frac{\\mathcal{F}_{34}(s)\\sigma_{34|12}(s)}{p_3^0p_4^0}.\\] and  $\\sigma_{34|12}(s)$  the lorentz invariant total cross section of the reverse reaction  $34\\to12$ ."},{"id":6,"pagetitle":"Overview","title":"Evaluation","ref":"/boltzmanncollisionintegral/stable/#Evaluation","content":" Evaluation Given a user input of interaction to evaluate and what discretisation to use, the discrete emission spectra  $S_{12|34,ijklmn}$ ,  $S_{12|43,ijklmn}$  and absorption spectra  $T_{12|34,ijkl}$ ,  $T_{21|34,ijkl}$  are solved simultaneously by Monte-Carlo integration. This provides all matricies required to self consistently model the evolution of particles due to the forward interaction  $12\\to34$ .  Note The order of the interaction in the absorption spectrum ( $34|12 \\to 12|34$ ) is changed for easier evaluation as sampled points can be used for both emission and absorption terms. Rather than solving for the forward and reverse reaction, only the forward reaction is solved for. Hence two sets of emission and absorption spectra are need to be generated in general to describe a single reversible reaction.   The evaluation is performed by the functions  SpectraEvaluateSerial  or  SpectraEvaluateMultiThread  depending on if the code is to run in serially on a single core or multi-threaded on multiple cores of a single CPU. The code will then save the resulting multidimensional arrays. Warning The evaluation does not guarantee convergence of the Monte-Carlo integration, instead it will sample only a user defined number of points. A rough measure of convergence is calculated (based on comparison to the output of the previous run) and stored as  SConverge  and  TConverge  in the output file. Evaluation is performed using  Float64  precision, with all  Internal Functions  designed to maintain accuracy to this precision. An in-depth setup guide is provided in the  Getting Started  section.  "},{"id":9,"pagetitle":"Cross Sections","title":"Implemented Particles and Binary Interactions","ref":"/boltzmanncollisionintegral/stable/crosssections/#Implemented-Particles-and-Binary-Interactions","content":" Implemented Particles and Binary Interactions"},{"id":10,"pagetitle":"Cross Sections","title":"Particles","ref":"/boltzmanncollisionintegral/stable/crosssections/#Particles","content":" Particles Below is a table of the currently implemented particles (i.e. their particle properties are defined within the code) Particle Abr. String Notes Sphere \"Sph\" Mass taken to be the mass of the Proton Electron \"Ele\" Positron \"Pos\" Proton \"Pro\""},{"id":11,"pagetitle":"Cross Sections","title":"Implemented Interactions","ref":"/boltzmanncollisionintegral/stable/crosssections/#Implemented-Interactions","content":" Implemented Interactions These binary interactions have currently been implemented: Collision of hard spheres  SphSphSphSph functions:  BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph BoltzmannCollisionIntegral.sigma_SphSphSphSph Photon pair production from electron positron annihilation  ElePosPhoPho functions:  BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho BoltzmannCollisionIntegral.sigma_ElePosPhoPho Electron positron pair production from photon pair annihilation  PhoPhoElePos functions:  BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos BoltzmannCollisionIntegral.sigma_PhoPhoElePos Electron(or Positron)-Photon scattering (Compton Scattering)  ElePhoElePho functions:  BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho BoltzmannCollisionIntegral.sigma_ElePhoElePho"},{"id":12,"pagetitle":"Cross Sections","title":"Adding User Defined Interactions","ref":"/boltzmanncollisionintegral/stable/crosssections/#Adding-User-Defined-Interactions","content":" Adding User Defined Interactions Users may add their own binary interaction cross sections to the  /src/commom/DifferentialCrossSectionFunctions.jl  file. Functions should be named in the following format:  \"sigma_name1name2name3name4\"  and  \"dsigmadt_name1name2name3name4\"  where the names are three letter abbreviations of the particles involved (see  Particles  for examples). The named pairs  name1name2  and  name3name4  should be in alphabetical order. Both the total cross section and differential cross sections must be provided for a single interaction.     All cross sections are to be defined in terms of the Mandelstram variables  $s=(p_1^\\mu+p_2^\\mu)^2$ ,  $t=(p_1^\\mu-p_3^\\mu)^2$  and  $u=(p_2^\\mu-p_3^\\mu)^2$ . To maintain accuracy of cross sections and avoid DivZero issues when momenta is small compared to the mass of the particles (at  Float64  precision), each Mandelstram variable in the cross sections should be split into two components: s=sSmol+sBig  where  $sBig = (m_1+m_2)^2$ t=tSmol+tBig  where  $tBig = (m_1-m_3)^2$ u=uSmol+uBig  where  $uBig = (m_2-m_3)^2$ The \"Big\" part typically cancels with terms in the cross sections, leading to better accuracy. Therefore the function should defined as follows: function sigma_name1name2name3name4(sSmol::Float64,sBig::Float64,tSmol::Float64,tBig::Float64,uSmol::Float64,uBig::Float64)\n    ... \nend\n\nfunction dsigmadt_name1name2name3name4(sSmol::Float64,sBig::Float64,tSmol::Float64,tBig::Float64,uSmol::Float64,uBig::Float64)\n    ... \nend where all of  sSmol ,  sBig ,  tSmol ,  tBig ,  uSmol , and  uBig  must be included in the function definition irrespective of if they actually appear in the cross section. It is also important to define a normalisation for the cross sections to avoid emission and absorption terms becoming small compared to the  Float64  minimum. Warning Total cross sections may typically be defined/derived in textbooks and other sources to include division by  $1/2$  if output states are identical. This factor should NOT be included here as this factor is included separably in the code. "},{"id":13,"pagetitle":"Cross Sections","title":"Differential and Total Cross Section Functions","ref":"/boltzmanncollisionintegral/stable/crosssections/#Differential-and-Total-Cross-Section-Functions","content":" Differential and Total Cross Section Functions Warning To ensure greater computational accuracy and prevent underflow of  $Float64$  precision values, all cross sections have a normalisation defined in the function documentation."},{"id":14,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_SphSphSphSph","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.sigma_SphSphSphSph","content":" BoltzmannCollisionIntegral.sigma_SphSphSphSph  —  Function sigma_SphSphSphSph(sSmol,sBig) returns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass)  $m_1,m_2,m_3,m_4=m_\\text{Sph}$ . Normalised by  $πR_{Sph}^2$ . \\[σ = \\frac{1}{2}\\] Arguments sSmol::Float64  : s - sBig sBig::Float64  : (m1+m2)^2 source"},{"id":15,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph","content":" BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph  —  Function dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for the binary interaction of hard spheres with normalised masses  $m_1,m_2,m_3,m_4=m_{\\text{Sph}}$ . Normalised by  $πR_{Sph}^2$ . \\[\\frac{dσ}{dt} = \\frac{1}{s-4m_{\\text{Sph}}^2}\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2=4m_{\\text{Sph}}^2$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2=0$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m_2-m_3)^2=0$ source"},{"id":16,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_ElePosPhoPho","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.sigma_ElePosPhoPho","content":" BoltzmannCollisionIntegral.sigma_ElePosPhoPho  —  Function sigma_ElePosPhoPho(sSmol,sBig) returns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[σ_{e^+e^-\\rightarrow\\gamma\\gamma} = \\frac{3}{4s^2(s-4)}\\left((s^2+4s-8)\\log\\left(\\frac{\\sqrt{s}+\\sqrt{s-4}}{\\sqrt{s}-\\sqrt{s-4}}\\right)-(s+4)\\sqrt{s(s-4)}\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$ source"},{"id":17,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho","content":" BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho  —  Function dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\frac{dσ_{e^+e^-\\rightarrow\\gamma\\gamma}}{dt} = -\\frac{3}{s(s-4)}\\left(\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)^2+\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)-\\frac{1}{4}\\left(\\frac{t-1}{u-1}+\\frac{u-1}{t-1}\\right)\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m2-m3)^2 = 1 ∴ u = uSmol + 1$ source"},{"id":18,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_PhoPhoElePos","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.sigma_PhoPhoElePos","content":" BoltzmannCollisionIntegral.sigma_PhoPhoElePos  —  Function sigma_PhoPhoElePos(sSmol,sBig) returns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[σ_{\\gamma\\gamma\\rightarrow e^+e^-} = \\frac{3}{2s^3}\\left((s^2+4s-8)\\log\\left(\\frac{\\sqrt(s)+\\sqrt(s-4)}{\\sqrt(s)-\\sqrt(s-4)}\\right)-(s+4)\\sqrt{s(s-4)}\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 0 ∴ s = sSmol$ source"},{"id":19,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos","content":" BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos  —  Function dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\frac{dσ_{\\gamma\\gamma\\rightarrow e^+e^-}}{dt} = -\\frac{3}{s^2}\\left(\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)^2+\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)-\\frac{1}{4}\\left(\\frac{t-1}{u-1}+\\frac{u-1}{t-1}\\right)\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 0 ∴ s = sSmol$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$ source"},{"id":20,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.sigma_ElePhoElePho","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.sigma_ElePhoElePho","content":" BoltzmannCollisionIntegral.sigma_ElePhoElePho  —  Function sigma_ElePhoElePho(sSmol,sBig) returns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\sigma_{e\\gamma\\rightarrow e\\gamma}(s)=\\frac{3}{4(s-1)}\\left[(1-\\frac{4}{\\left(s-1\\right)}-\\frac{8m_e^4}{\\left(s-1\\right)^2})\\log\\left(s\\right)+\\frac{1}{2}+\\frac{8}{s-1}-\\frac{1}{2s^2}\\right]\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$ source"},{"id":21,"pagetitle":"Cross Sections","title":"BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho","ref":"/boltzmanncollisionintegral/stable/crosssections/#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho","content":" BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho  —  Function dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\frac{d\\sigma_{e\\gamma\\rightarrow e\\gamma}}{dt}(s,t)=\\frac{3}{(s-1)^2}\\left[\\left(\\frac{1}{s-1}+\\frac{1}{u-1}\\right)^2+\\left(\\frac{1}{s-1}+\\frac{1}{u-1}\\right)-\\frac{1}{4}\\left(\\frac{s-1}{u-1}+\\frac{u-1}{s-1}\\right)\\right]\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2 = 0 ∴ t = tSmol$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$ source"},{"id":24,"pagetitle":"Internal Functions","title":"Internal Functions","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#Internal-Functions","content":" Internal Functions"},{"id":25,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.DoesConserve","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}","content":" BoltzmannCollisionIntegral.DoesConserve  —  Method DoesConserve(SMatrix3,SMatrix4,TMatrix1,TMatrix2,Parameters) Function prints the ratio of the sum of the S and T matricies and their differences, for all interaction paths, as to check number and energy conservation for a particular interaction. Arguments are as outputted by the  fload_All  function.  source"},{"id":26,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFlux","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float64, Float64, Float64}","content":" BoltzmannCollisionIntegral.InvarientFlux  —  Method InvarientFlux(s,mu12,mu22) returns the value of the invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2' source"},{"id":27,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFlux2","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float64, Float64, Float64}","content":" BoltzmannCollisionIntegral.InvarientFlux2  —  Method InvarientFlux2(s,mass12,mass22) returns the value of the squared invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2' source"},{"id":28,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFlux2Small","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float64, Float64, Float64}","content":" BoltzmannCollisionIntegral.InvarientFlux2Small  —  Method InvarientFluxSmall(sSmol,mass12,mass22) returns the value of the squared invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2) source"},{"id":29,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.InvarientFluxSmall","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float64, Float64, Float64}","content":" BoltzmannCollisionIntegral.InvarientFluxSmall  —  Method InvarientFluxSmall(sSmol,mu12,mu22) returns the value of the invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2) source"},{"id":30,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.Momentum3Value!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}","content":" BoltzmannCollisionIntegral.Momentum3Value!  —  Method Momentum3Value!(p3v,p3pv,p1v,p2v) Takes set of random initial particle states 'p1v' and 'p2v' and random output states angles 'p3v[2:3]' and modifies outputs 'p3v' and 'p3pv' values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools 'p3 physical' and 'p3p physical' indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int 'NumStates' indicating the number of valid output states found. Requrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const. Examples julia> mu1 = 1836.1528e0\njulia> mu2 = 1836.1528e0\njulia> mu3 = 1836.1528e0\njulia> mu4 = 1836.1528e0\njulia> p1v = [1e0, 0.5e0, 1.8e0]\njulia> p2v = [2e0, 0.2e0, 0.7e0]\njulia> p3v = [0e0, 0.3e0, 0.7e0]\njulia> p3pv = zeros(Float64,3)\njulia> p3pv .= p3v\njulia> Momentum3Value!(p3v,p3pv,p1v,p2v,mu1,mu2,mu3,mu4)\n(true,true,2)\njulia> p3v\n 3-element Vector{Float64}:\n 2.04505\n 0.3\n 0.7\njulia> p3pv\n 3-element Vector{Float64}\n 0.691423\n -0.3\n 1.7 source"},{"id":31,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactors1!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}","content":" BoltzmannCollisionIntegral.PhaseSpaceFactors1!  —  Method PhaseSpaceFactors1!(SMatrix3,SMatrix4,TMatrix,t3val,t4val,p1val,t1val,p2val,t2val,Indeistinguishable_12) Applies phase space volume element factors for 'SMatrix' and 'TMatrix' terms in order to correctly apply 'STSymmetry' corrections.  source"},{"id":32,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactors2!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{Float64, 4}, Vararg{Vector{Float64}, 8}}","content":" BoltzmannCollisionIntegral.PhaseSpaceFactors2!  —  Method PhaseSpaceFactors2!(SMatrix3,SMatrix4,TMatrix,p3val,t3val,p4val,t4val,p1val,t1val,p2val,t2val) To follow 'PhaseSpaceFactors1' and 'STSymmetry'. Corrects phase space factors on 'SMatrix' and 'TMatrix' for use in kinetic codes. Assumes f(x,p,μ)= constant source"},{"id":33,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}","content":" BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!  —  Method PhaseSpaceFactorsSync1!(SMatrix,p1val,t1val,p2val,t2val) Applies phase space volume element factors for 'SMatrix' terms in order to correctly apply 'SyncSymmetry' corrections.  source"},{"id":34,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}","content":" BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!  —  Method PhaseSpaceFactorsSync2!(SMatrix,p1val,t1val) To follow 'PhaseSpaceFactorsSync1' and 'SyncSymmetry'. Correct phase spcae factors on 'SMatrix' for use in kinetic codes.  source"},{"id":35,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.RPointLogMomentum!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}","content":" BoltzmannCollisionIntegral.RPointLogMomentum!  —  Method RPointLogMomentum!(pu,pl,pv,num) Edits the first element of  pv  with a random real-space momentum value between  $10^{pl}$  and  $10^{pu}$ . This sample is chosen by first randomly picking a momentum bin in the range  1:num  and then uniformly sampling a momentum point in real-space (rather than log10 space) between pl and pu which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between  $10^{pl}$  and  $10^{pu}$  it is a spherical shell hence the correct sampling is  $p = (U*(10^{pu})^3+(1-U)*(10^{pl})^3)^{1/3}$  with uniform  $U ∈ [0~~1]$ . Assumes  $f(x,p,μ)=f(x,\\vec{p})*(2πp^2)=const$  in bin, therefore momentum space volume element is  $\\mathrm{d}p$  and as such uniform sampling corresponds to  $U*10^{u}+(1-U)*10^{l}$  where  $U$  is a uniform random number between 0 and 1. If instead  $f(x,\\vec{p})=const$  in bin, momentum space volume element is  $p^2 \\mathrm{d}p$  and uniform sampling corresponds to  $(10^pu)*\\sqrt[3]{U+(1-U)*10^{3pl-3pu}}$  where  $U$  is a uniform random number between 0 and 1. source"},{"id":36,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.RPointSphereCosTheta!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}","content":" BoltzmannCollisionIntegral.RPointSphereCosTheta!  —  Method RPointSphereTheta!() Assigns the second (cos(theta)) element of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta).  source"},{"id":37,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}","content":" BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!  —  Method RPointSphereThetaPhi!() Assigns the second (cos(theta)) and third (phi) elements of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi).  source"},{"id":38,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}","content":" BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!  —  Method STMonteCarloAxi_MultiThread!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,t3MinMax,p4Max,t4MinMax,sigma,dsigmadt,Parameters,numTiterPerThread,numSiterPerThread) Arguments SAtotal3::Array{Float64,6}  : Array of stored integration totals for S matrix for 12->34 interaction SAtotal4::Array{Float64,6}  : Array of stored integration totals for S matrix for 12->43 interaction TAtotal::Array{Float64,4}  : Array of stored integration totals for T matrix SAtally3::Array{UInt32,5}  : Array of stored integration tallies for S matrix for 12->34 interaction SAtally4::Array{UInt32,5}  : Array of stored integration tallies for S matrix for 12->43 interaction TAtally::Array{UInt32,4}  : Array of stored integration tallies for T matrix p3Max::Array{Float64,5}  : Array of maximum momentum values for species 3 t3MinMax::Array{Float64,6}  : Array of minimum and maximum theta values for species 3 p4Max::Array{Float64,5}  : Array of maximum momentum values for species 4 t4MinMax::Array{Float64,6}  : Array of minimum and maximum theta values for species 4 sigma::Function  : Cross section function for the interaction dsigmadt::Function  : Differential cross section function for the interaction Parameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64}  : Tuple of parameters for the interaction numTiterPerThread::Int64  : Number of T iterations per thread numSiterPerThread::Int64  : Number of S iterations per thread Output: Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration. Calculation In Breif Set up worker threads Random Sample points in each of these domains RandomPointSphere for theta and phi (for species 1,2,3,4) RandomPointMomentum for p ( species 1,2 only) Take random points (t3,h3,p1,p2,t1,t2,h1,h2) and calculate valid p3 point/points  Find position in local S and T arrays and allocated tallies and totals accordingly. Take random points (t4,h3,p1,p2,t1,t2,h1,h2) and calculate valid p4 point/points  Find position in local S and T arrays and allocated tallies and totals accordingly. Update global S and T arrays with locks to prevent data races source"},{"id":39,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}","content":" BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!  —  Method STMonteCarloAxi_Serial!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,p4Max,t3MinMax,t4MinMax,sigma,dsigmadt,Parameters,numTiter,numSiter) Arguments SAtotal3::Array{Float64,6}  : Array of stored integration totals for S matrix for 12->34 interaction SAtotal4::Array{Float64,6}  : Array of stored integration totals for S matrix for 12->43 interaction TAtotal::Array{Float64,4}  : Array of stored integration totals for T matrix SAtally3::Array{UInt32,5}  : Array of stored integration tallies for S matrix for 12->34 interaction SAtally4::Array{UInt32,5}  : Array of stored integration tallies for S matrix for 12->43 interaction TAtally::Array{UInt32,4}  : Array of stored integration tallies for T matrix p3Max::Array{Float64,5}  : Array of maximum momentum values for species 3 t3MinMax::Array{Float64,6}  : Array of minimum and maximum theta values for species 3 p4Max::Array{Float64,5}  : Array of maximum momentum values for species 4 t4MinMax::Array{Float64,6}  : Array of minimum and maximum theta values for species 4 sigma::Function  : Cross section function for the interaction dsigmadt::Function  : Differential cross section function for the interaction Parameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64}  : Tuple of parameters for the interaction numTiter::Int64  : Number of T iterations numSiter::Int64  : Number of S iterations Output: Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration. Calculation In Breif Random Sample points in each of these domains RandomPointSphere for theta and phi (for species 1,2,3,4) RandomPointMomentum for p ( species 1,2 only) Take random points (t3,h3,p1,p2,t1,t2,h1,h2) and calculate valid p3 point/points  Find position in local S and T arrays and allocated tallies and totals accordingly. Take random points (t4,h3,p1,p2,t1,t2,h1,h2) and calculate valid p4 point/points  Find position in local S and T arrays and allocated tallies and totals accordingly. source"},{"id":40,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.STSymmetry!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Float64, Float64}","content":" BoltzmannCollisionIntegral.STSymmetry!  —  Method STSymmetry!(SMatrix3,SMatrix4,TMatrix,t3val,mu1,mu2) To follow 'PhaseSpaceFactors1'. Physical nature of binary interaction has certain symmetries. 'STSymmetry' uses these symmetries to improve MC sampling of 'SMatrix' and 'TMatrix'. source"},{"id":41,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SValue3","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}","content":" BoltzmannCollisionIntegral.SValue3  —  Method SValue3(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3) Returns  Sval  from MC integration based on initial momentum states  p1v  and  p2v  and final state  p3v  and differential cross section  dsigmadt  based on particle selection 12->34.   Assumes f(x,p,μ)=constant over bin source"},{"id":42,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SValue4","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}","content":" BoltzmannCollisionIntegral.SValue4  —  Method SValue4(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3,mu4) Returns  Sval  from MC integration based on initial momentum states  p1v  and  p2v  and final state  p4v  and differential cross section  dsigmadt  based on particle selection 12->34.   Assumes f(x,p,μ)=constant over bin source"},{"id":43,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SpectraEvaluateMultiThread","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}","content":" BoltzmannCollisionIntegral.SpectraEvaluateMultiThread  —  Method SpectraEvaluateMultiThread(userInputMultiThread) Function to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matricies and save the results to a file. source"},{"id":44,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SpectraEvaluateSerial","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}","content":" BoltzmannCollisionIntegral.SpectraEvaluateSerial  —  Method SpectraEvaluateSerial(userInputSerial) Function to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matricies and save the results to a file. source"},{"id":45,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncEvaluateMultiThread","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Any}","content":" BoltzmannCollisionIntegral.SyncEvaluateMultiThread  —  Method SyncEvaluateMultiThread!(userSyncInputMultiThread) Function to run the Monte Carlo integration of the S array in a serial enviroment.  source"},{"id":46,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncEvaluateSerial","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Any}","content":" BoltzmannCollisionIntegral.SyncEvaluateSerial  —  Method SyncEvaluateSerial!(userSyncInputSerial) Function to run the Monte Carlo integration of the S array in a serial enviroment.  source"},{"id":47,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncKernel","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}","content":" BoltzmannCollisionIntegral.SyncKernel  —  Method SyncKernel(p1v,p2v,m2,z2,B) Returns the emission rate for a single photon  $p1v$  state emitted by a charged particle in state  $p2v$  with charge  $z2$  relative to the fundamental charge and mass  $m2$  relative to the mass of the electron, in a unifrom magnetic field  $B$ . source"},{"id":48,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64, Int64}","content":" BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!  —  Method SyncMonteCarloAxi_MultiThread!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter) Arguments SAtotal::Array{Float64,4}  : Array of stored integration totals for S matrix for 2+B->2+B+1 interaction SAtally::Array{UInt32,4}  : Array of stored integration tallies for S matrix for 2+B->2+B+1 interaction pMax::Array{Float64,3}  : Array of maximum momentum values for species 2 tMinMax::Array{Float64,3}  : Array of minimum and maximum theta values for species 2 Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}  : Tuple of parameters for the interaction numSiter::Int64  : Number of S iterations Output: Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration. Calculation In Breif Random Sample points in each of these domains RandomPointSphere for theta (for species 1,2) RandomPointMomentum for p ( species 1,2) Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity Find position in S arrays and allocated tallies and totals accordingly. source"},{"id":49,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64}","content":" BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!  —  Method SyncMonteCarloAxi_Serial!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter) Arguments SAtotal::Array{Float64,4}  : Array of stored integration totals for S matrix for 2+B->2+B+1 interaction SAtally::Array{UInt32,4}  : Array of stored integration tallies for S matrix for 2+B->2+B+1 interaction pMax::Array{Float64,3}  : Array of maximum momentum values for species 2 tMinMax::Array{Float64,3}  : Array of minimum and maximum theta values for species 2 Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}  : Tuple of parameters for the interaction numSiter::Int64  : Number of S iterations Output: Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration. Calculation In Breif Random Sample points in each of these domains RandomPointSphere for theta (for species 1,2) RandomPointMomentum for p ( species 1,2) Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity Find position in S arrays and allocated tallies and totals accordingly. source"},{"id":50,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.SyncSymmetry!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}","content":" BoltzmannCollisionIntegral.SyncSymmetry!  —  Method SyncSymmetry!(SMatrix) To follow 'PhaseSpaceFactorsSync1'. Synchrotron emission has a symmetry with respect to cos(theta) -> -cos(theta) for both initial particle and photon momenta. source"},{"id":51,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.TValue","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}","content":" BoltzmannCollisionIntegral.TValue  —  Method TValue(p1v,p2v,sigma,mu1,mu2) returns  Tval  with its Tval from MC integration based on initial momentum states  p1v  and  p2v  and cross section  sigma  based on particle selection. If initial state fails  sCheck , i.e. cannot generate a physical output state, Tval is set to 0e0.  Assumes f(x,p,μ)=constant over bin source"},{"id":52,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.deltaEVector","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:Union{Float32, Float64}","content":" BoltzmannCollisionIntegral.deltaEVector  —  Method deltaEVector(pr,mu) Inputs a  num+1  long  Vector{Float}  of p grid boundries and the particle  mu  value (normalised mass) and returns a  num  long  Vector{Float}  of average energy values per grid cell. Examples julia> deltaEVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)\n3-element Vector{Float64}:\n 50.600693\n 4951.15\n 495001.16 source"},{"id":53,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.deltaEkinVector","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:Union{Float32, Float64}","content":" BoltzmannCollisionIntegral.deltaEkinVector  —  Method deltaEkinVector(pr,mu) Inputs a  num+1  long  Vector{Float}  of p grid boundries and the particle  mu  value (normalised mass) and returns a  num  long  Vector{Float}  of average kinetic energy values per grid cell. Examples julia> deltaEkinVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)\n3-element Vector{Float64}:\n     46.10069600605712\n   4906.1506753523645\n 494551.15128635924 source"},{"id":54,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.deltaVector","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{Float32, Float64}","content":" BoltzmannCollisionIntegral.deltaVector  —  Method deltaVector(valr) Inputs a  num+1  long  Vector{Float}  quantitiy values (domain bounds) and returns a  num  long  Vector{Float}  of differeces (domain widths). Examples julia> deltaVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])\n3-element Vector{Float64}:\n 9.0\n 90.0\n 900.0 source"},{"id":55,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}","content":" BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho  —  Method dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\frac{d\\sigma_{e\\gamma\\rightarrow e\\gamma}}{dt}(s,t)=\\frac{3}{(s-1)^2}\\left[\\left(\\frac{1}{s-1}+\\frac{1}{u-1}\\right)^2+\\left(\\frac{1}{s-1}+\\frac{1}{u-1}\\right)-\\frac{1}{4}\\left(\\frac{s-1}{u-1}+\\frac{u-1}{s-1}\\right)\\right]\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2 = 0 ∴ t = tSmol$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$ source"},{"id":56,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}","content":" BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho  —  Method dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\frac{dσ_{e^+e^-\\rightarrow\\gamma\\gamma}}{dt} = -\\frac{3}{s(s-4)}\\left(\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)^2+\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)-\\frac{1}{4}\\left(\\frac{t-1}{u-1}+\\frac{u-1}{t-1}\\right)\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m2-m3)^2 = 1 ∴ u = uSmol + 1$ source"},{"id":57,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}","content":" BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos  —  Method dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\frac{dσ_{\\gamma\\gamma\\rightarrow e^+e^-}}{dt} = -\\frac{3}{s^2}\\left(\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)^2+\\left(\\frac{1}{t-1}+\\frac{1}{u-1}\\right)-\\frac{1}{4}\\left(\\frac{t-1}{u-1}+\\frac{u-1}{t-1}\\right)\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 0 ∴ s = sSmol$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$ source"},{"id":58,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}","content":" BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph  —  Method dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig) returns the differential cross section for the binary interaction of hard spheres with normalised masses  $m_1,m_2,m_3,m_4=m_{\\text{Sph}}$ . Normalised by  $πR_{Sph}^2$ . \\[\\frac{dσ}{dt} = \\frac{1}{s-4m_{\\text{Sph}}^2}\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2=4m_{\\text{Sph}}^2$ tSmol::Float64  :  $t - tBig$ tBig::Float64  :  $(m_3-m_1)^2=0$ uSmol::Float64  :  $u - uBig$ uBig::Float64  :  $(m_2-m_3)^2=0$ source"},{"id":59,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_All","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.fload_All-Tuple{String, String}","content":" BoltzmannCollisionIntegral.fload_All  —  Method fload_All(fileLocation,fileName) Loads all the data stored in  fileName  stored at  fileLocation . Example     (Run_Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,t3MinMax,t4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName); Returns a tuple of the data stored in the file. The fields are as follows: Run_Parameters  : A tuple of the parameters used in the evaluation. Stot3  : A 6D matrix totalling all the emission spectrum values sampled for 12->34 interaction. Stot4  : A 6D matrix totalling all the emission spectrum values sampled for 12->43 interaction. Ttot  : A 4D matrix totalling all the absorption spectrum values sampled. Stal3  : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->34 interaction. Stal4  : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->43 interaction. Ttal  : A 4D matrix of tallies of the number of absorption spectrum values sampled. SMatrix3  : A 6D matrix of the emission spectrum for 12->34 interaction. SMatrix4  : A 6D matrix of the emission spectrum for 12->43 interaction. TMatrix1  : A 4D matrix of the absorption spectrum for 12->34 interaction. TMatrix2  : A 4D matrix of the absorption spectrum for 21->34 interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2. p3Max  : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion) t3MinMax  : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion) p4Max  : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion) t4MinMax  : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion) SConv3  : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given  Run_Parameters  for 12->34 interaction. SConv4  : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given  Run_Parameters  for 12->43 interaction. TConv  : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given  Run_Parameters . source"},{"id":60,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_All_Sync","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}","content":" BoltzmannCollisionIntegral.fload_All_Sync  —  Method fload_All_Sync(fileLocation,fileName) Loads all the data stored in  fileName  stored at  fileLocation . Example     (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#SConv) = fload_All_Sync(fileLocation,fileName); Returns a tuple of the data stored in the file. The fields are as follows: Run_Parameters  : A tuple of the parameters used in the evaluation. Stot  : A 4D matrix totalling all the synchrotron emission spectrum values Stal  : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled SMatrix  : A 4D matrix of the synchrotron emission spectrum. pMax  : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion) tMinMax  : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion) SConv  : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given  Run_Parameters . source"},{"id":61,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}","content":" BoltzmannCollisionIntegral.fload_Matrix  —  Method fload_Matrix(fileLocation,fileName) Loads just the S and T Matricies stored in  fileName  stored at  fileLocation . Example     Matricies = fload_All(fileLocation,fileName); Returns a tuple of the data stored in the file. The fields are as follows: Run_Parameters  : A tuple of the parameters used in the evaluation. SMatrix3  : A 6D matrix of the emission spectrum for 12->34 interaction. SMatrix4  : A 6D matrix of the emission spectrum for 12->43 interaction. TMatrix1  : A 4D matrix of the absorption spectrum for 12->34 interaction. TMatrix2  : A 4D matrix of the absorption spectrum for 21->34 interaction. If initial or final particles are identical then only one of the SMatricies or TMatricies will be returned for that state. source"},{"id":62,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix_ISO","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}","content":" BoltzmannCollisionIntegral.fload_Matrix_ISO  —  Method fload_Matrix_ISO(fileLocation,fileName) Loads just the S and T Matricies stored in  fileName  stored at  fileLocation  first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D->6D with three dimensions having a size of 1) Example     Matricies = fload_All_ISO(fileLocation,fileName); Returns a tuple of the data stored in the file. The fields are as follows: Run_Parameters  : A tuple of the parameters used in the evaluation. SMatrix3  : A 6D matrix of the emission spectrum for 12->34 interaction. SMatrix4  : A 6D matrix of the emission spectrum for 12->43 interaction. TMatrix1  : A 4D matrix of the absorption spectrum for 12->34 interaction. TMatrix2  : A 4D matrix of the absorption spectrum for 21->34 interaction. If initial or final particles are identical then only one of the SMatricies or TMatricies will be returned for that state. source"},{"id":63,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix_Sync","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}","content":" BoltzmannCollisionIntegral.fload_Matrix_Sync  —  Method fload_Matrix_Sync(fileLocation,fileName) Loads just the S and T Matricies stored in  fileName  stored at  fileLocation .  Example     Matricies = fload_Matrix_Sync(fileLocation,fileName); Returns a tuple of the data stored in the file. The fields are as follows: SMatrix  : A 4D matrix of the emission spectrum for Synchrotron. source"},{"id":64,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.fload_Matrix_SyncISO","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}","content":" BoltzmannCollisionIntegral.fload_Matrix_SyncISO  —  Method fload_Matrix_SyncISO(fileLocation,fileName) Loads just the S and T Matricies stored in  fileName  stored at  fileLocation  first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D->6D with three dimensions having a size of 1) Example     Matricies = fload_Matrix_SyncISO(fileLocation,fileName); Returns a tuple of the data stored in the file. The fields are as follows: SMatrix  : A 4D matrix of the emission spectrum for Synchrotron. source"},{"id":65,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.location","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64}","content":" BoltzmannCollisionIntegral.location  —  Method location(u,l,num,val) Returns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound. Examples julia> location(10e0,0e0,9,2e0)\n2 source"},{"id":66,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.location_p","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}","content":" BoltzmannCollisionIntegral.location_p  —  Method location_p(u,l,num,val) Returns the index of the momentum bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1. Examples julia> location_p(10e0,1e0,9,2e0)\n2\njulia> location_p(10e0,1e0,9,11e0) # overflow\n10\njulia> location_p(10e0,1e0,9,0.5e0) # underflow\n1 source"},{"id":67,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.location_t","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}","content":" BoltzmannCollisionIntegral.location_t  —  Method location_t(numt,val) Returns the index of the bin in which the costheta 'val' is contatined based on the 'numt' of bins. Bounds [tl tu] are defined as CONST in Init.jl Examples julia> location_t(8,0.5e0)\n6 source"},{"id":68,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.meanVector","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{Float32, Float64}","content":" BoltzmannCollisionIntegral.meanVector  —  Method meanVector(valr) Inputs a  num+1  long  Vector{Float}  of domain bounds and returns a  num  long  Vector{Float}  of mean value in domain range. Examples julia> meanVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])\n3-element Vector{Float64}:\n 5.5\n 55.0\n 550.0 source"},{"id":69,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.p4Vector!","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.p4Vector!-NTuple{4, Vector{Float64}}","content":" BoltzmannCollisionIntegral.p4Vector!  —  Method p4Vector!(p4v,p3v,p1v,p2v) Returns the p4 vector (in standard form [p,cos(theta),phi/pi]) given the p1, p2 and p3 vectors using conservation of momentum. source"},{"id":70,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.prange","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.prange-Union{Tuple{T}, Tuple{T, T, Int64}} where T<:Union{Float32, Float64}","content":" BoltzmannCollisionIntegral.prange  —  Method prange(pl,pu,nump) Returns a  nump+1  long  Vector{Float}  of p-space grid bounds NOT in Log10 space. Examples julia> prange(-5e0,4e0,9)\n10-element Vector{Float64}:\n 1.0e-5\n 1.0e-4\n 1.0e-3\n 0.01\n 0.1\n 1.0\n 10.0\n 100.0\n 1000.0\n 10000.0 source"},{"id":71,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.sCheck","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}","content":" BoltzmannCollisionIntegral.sCheck  —  Method sCheck(sSmol,sBig,mu3,mu4) Returns 'true' if 's' mandelstram generated from inital system state can generate a physical output state.  source"},{"id":72,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_ElePhoElePho","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}","content":" BoltzmannCollisionIntegral.sigma_ElePhoElePho  —  Method sigma_ElePhoElePho(sSmol,sBig) returns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[\\sigma_{e\\gamma\\rightarrow e\\gamma}(s)=\\frac{3}{4(s-1)}\\left[(1-\\frac{4}{\\left(s-1\\right)}-\\frac{8m_e^4}{\\left(s-1\\right)^2})\\log\\left(s\\right)+\\frac{1}{2}+\\frac{8}{s-1}-\\frac{1}{2s^2}\\right]\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$ source"},{"id":73,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_ElePosPhoPho","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}","content":" BoltzmannCollisionIntegral.sigma_ElePosPhoPho  —  Method sigma_ElePosPhoPho(sSmol,sBig) returns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[σ_{e^+e^-\\rightarrow\\gamma\\gamma} = \\frac{3}{4s^2(s-4)}\\left((s^2+4s-8)\\log\\left(\\frac{\\sqrt{s}+\\sqrt{s-4}}{\\sqrt{s}-\\sqrt{s-4}}\\right)-(s+4)\\sqrt{s(s-4)}\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$ source"},{"id":74,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_PhoPhoElePos","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}","content":" BoltzmannCollisionIntegral.sigma_PhoPhoElePos  —  Method sigma_PhoPhoElePos(sSmol,sBig) returns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron  $m_{\\text{Ele}}$  and the cross section is normalised by  $σ_T$ . \\[σ_{\\gamma\\gamma\\rightarrow e^+e^-} = \\frac{3}{2s^3}\\left((s^2+4s-8)\\log\\left(\\frac{\\sqrt(s)+\\sqrt(s-4)}{\\sqrt(s)-\\sqrt(s-4)}\\right)-(s+4)\\sqrt{s(s-4)}\\right)\\] Arguments sSmol::Float64  :  $s - sBig$ sBig::Float64  :  $(m_1+m_2)^2 = 0 ∴ s = sSmol$ source"},{"id":75,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.sigma_SphSphSphSph","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}","content":" BoltzmannCollisionIntegral.sigma_SphSphSphSph  —  Method sigma_SphSphSphSph(sSmol,sBig) returns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass)  $m_1,m_2,m_3,m_4=m_\\text{Sph}$ . Normalised by  $πR_{Sph}^2$ . \\[σ = \\frac{1}{2}\\] Arguments sSmol::Float64  : s - sBig sBig::Float64  : (m1+m2)^2 source"},{"id":76,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.trange","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.trange-Tuple{Int64}","content":" BoltzmannCollisionIntegral.trange  —  Method trange(numt) Returns a  numt+1  long  Vector{Float}  of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1 1], type returned is that of tl, tu. Examples julia> trange(8)\n9-element Vector{Float64}:\n -1.0\n -0.75\n -0.5\n -0.25\n  0.0\n  0.25\n  0.5\n  0.75\n  1.0 source"},{"id":77,"pagetitle":"Internal Functions","title":"BoltzmannCollisionIntegral.vectorLocation","ref":"/boltzmanncollisionintegral/stable/internalfunctions/#BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}","content":" BoltzmannCollisionIntegral.vectorLocation  —  Method vectorLocation(pu,pl,nump,numt,vector) Returns a tuple of bin location for (log10momentum,cos(theta)) based on an input 'vector' and bounds 'u,l' of their domains and the 'num' of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl Examples ```julia-repl julia> vectorLocation(4e0,-5e0,9,8,[1e0,0.5e0,1.5e0]) (5,6) source"},{"id":80,"pagetitle":"Getting Started","title":"Getting Started","ref":"/boltzmanncollisionintegral/stable/quickstart/#Getting-Started","content":" Getting Started"},{"id":81,"pagetitle":"Getting Started","title":"Installation","ref":"/boltzmanncollisionintegral/stable/quickstart/#Installation","content":" Installation BoltzmannCollisionIntegral.jl is available to download from the Julia package manager. Inside a Julia session, enter the package manager with  ] , then run the command pkg> add BoltzmannCollisionIntegral finally load the package by running using BoltzmannCollisionIntegral"},{"id":82,"pagetitle":"Getting Started","title":"Integrating","ref":"/boltzmanncollisionintegral/stable/quickstart/#Integrating","content":" Integrating BoltzmannCollisionIntegral.jl contains the following modules: Binary Interactions 12->34 Synchrotron emission    "},{"id":83,"pagetitle":"Getting Started","title":"Quick Start for Binary Interactions Module","ref":"/boltzmanncollisionintegral/stable/quickstart/#Quick-Start-for-Binary-Interactions-Module","content":" Quick Start for Binary Interactions Module Note An example script  Run_Integration.jl  for setting up and running the evaluation of the discrete binary collision integral can be found under  src/Common/  of the package. It is recommended that you copy this script to your working directory, edit the relevant fields and then running, either using the command  include(\"Run_Integration.jl) in a julia-repl session, or by running the script line by line in your favourite code editor. The example script  Run_Integration.jl  operates as follows: Define the names of the 4 particles involved in the interaction ( $12\\to34$ ) as the strings  name1 name2 name3 name4 These should of the form of three letters, which abbreviate the particles full name (see  Particles  for list of currently implemented particles). They should be ordered to match a currently  Implemented Interactions Define the momentum space discretisation. This includes the upper and lower bounds of momentum (log10) for particle species 1,2 and 3 (e.g.  p1l  and  p1u  for species 1) and the number of divisions (bins) for each particles momentum space (e.g.  nump1 ). Define the number of divisions for the angular momentum space (i.e. cos(theta) space) for the particle species 1,2 and 3 (e.g.  numt1 ).  Define the number of Monte-Carlo samples to perform (as a rule of thumb, on a modern CPU it takes approximately 200ns per sample). numTiter  for the number of random sets of  $\\{\\vec{p}_1,\\vec{p}_2\\}$  to sample.  numSiter  for the number of random  $\\{\\vec{p}_3\\}$  states to sample per  $\\{\\vec{p}_1,\\vec{p}_2\\}$ . If multithreading then define  nThreads  that will be used. This generates  nThreads  workers that perform evaluation in parallel, utilising  locks  to prevent data races. (see  Multi-Threading  for how to set up multi-threading in Julia) Define the  fileLocation  where the output file ( JLD2 ) named  fileName  is to be written. Evaluate the emission and absorption spectrum using the  SpectraEvaluateSerial  function for serial and  SpectraEvaluateMultiThread  for multithread. Once run, these functions will save the results to the output file."},{"id":84,"pagetitle":"Getting Started","title":"Quick Start for Synchrotron Module","ref":"/boltzmanncollisionintegral/stable/quickstart/#Quick-Start-for-Synchrotron-Module","content":" Quick Start for Synchrotron Module Note An example script  Run_Integration_Sync.jl  for setting up and running the evaluation of the discrete binary collision integral can be found under  src/Synchrotron/Common/  of the package. It is recommended that you copy this script to your working directory, edit the relevant fields and then running, either using the command  include(\"Run_Integration_Sync.jl) in a julia-repl session, or by running the script line by line in your favourite code editor. The example script  Run_Integration_Sync.jl  operates as follows: Define the name of the emitting particle as the strings  name2 This should of the form of three letters, which abbreviate the particles full name (see  Particles  for list of currently implemented particles). Define the momentum space discretisation. This includes the upper and lower bounds of momentum (log10) for the emitted photons (species 1) and emitting particle (species 2) i.e.  p1l  and  p1u  for species 1, and the number of divisions (bins) for each particles momentum space, i.e.  nump1 . Define the number of divisions for the angular momentum space (i.e. cos(theta) space) for the particle species 1 and 2 (i.e.  numt1 ).  Define the number of Monte-Carlo samples to perform (as a rule of thumb, on a modern CPU it takes approximately 200ns per sample). numTiter  for the number of random sets of  $\\{\\vec{p}_2\\}$  to sample, i.e. emitting particle states.  numSiter  for the number of random  $\\{\\vec{p}_2\\}$  states to sample per  $\\{\\vec{p}_2\\}$ , i.e. number of emitted photons to sample per emitting particle state. If multithreading then define  nThreads  that will be used. This generates  nThreads  workers that perform evaluation in parallel, utilising  locks  to prevent data races. (see  Multi-Threading  for how to set up multi-threading in Julia) Define the  fileLocation  where the output file ( JLD2 ) named  fileName  is to be written. Evaluate the emission and absorption spectrum using the  SyncEvaluateSerial  function for serial and  SyncEvaluateMultiThread  for multithread. Once run, these functions will save the results to the output file."},{"id":85,"pagetitle":"Getting Started","title":"Output Files","ref":"/boltzmanncollisionintegral/stable/quickstart/#Output-Files","content":" Output Files"},{"id":86,"pagetitle":"Getting Started","title":"Output for Binary Interactions","ref":"/boltzmanncollisionintegral/stable/quickstart/#Output-for-Binary-Interactions","content":" Output for Binary Interactions The data stored in an output file can be loaded back into the workspace as a tuple using the  fload_All  function.     (Run_Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,t3MinMax,t4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName) This returns a  Tuple  containing various arrays: Run_Parameters  : A tuple of the parameters used in the evaluation. Stot3  : A 6D matrix totalling all the emission spectrum values sampled for  $12\\to34$  interaction. Stot4  : A 6D matrix totalling all the emission spectrum values sampled for  $12\\to43$  interaction. Ttot  : A 4D matrix totalling all the absorption spectrum values sampled. Stal3  : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->34 interaction. Stal4  : A 5D matrix of tallies of the number of emission spectrum values sampled for 12->43 interaction. Ttal  : A 4D matrix of tallies of the number of absorption spectrum values sampled. SMatrix3  : A 6D matrix of the emission spectrum for  $12\\to34$  interaction. SMatrix4  : A 6D matrix of the emission spectrum for  $12\\to43$  interaction. TMatrix1  : A 4D matrix of the absorption spectrum for  $12\\to34$  interaction. TMatrix2  : A 4D matrix of the absorption spectrum for  $21\\to34$  interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2. p3Max  : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion) t3MinMax  : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion) p4Max  : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion) t4MinMax  : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion) SConv3  : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given  Run_Parameters  for  $12\\to34$  interaction. SConv4  : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given  Run_Parameters  for  $12\\to43$  interaction. TConv  : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given  Run_Parameters . Conservation of particle number and energy can be checked using the  DoesConserve  function. The key statistic is  ratioN  and  ratioE  which dictate the ratio of particle number and energy before and after the interaction and should be close to 1."},{"id":87,"pagetitle":"Getting Started","title":"Output for Synchrotron","ref":"/boltzmanncollisionintegral/stable/quickstart/#Output-for-Synchrotron","content":" Output for Synchrotron The data stored in an output file can be loaded back into the workspace as a tuple using the  fload_All_Sync  function.     (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#,SConv) = fload_All_Sync(fileLocation,fileName) Returns a tuple of the data stored in the file. The fields are as follows: Run_Parameters  : A tuple of the parameters used in the evaluation. Stot  : A 4D matrix totalling all the synchrotron emission spectrum values Stal  : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled SMatrix  : A 4D matrix of the synchrotron emission spectrum. pMax  : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion) tMinMax  : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion) SConv  : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given  Run_Parameters ."},{"id":90,"pagetitle":"Synchrotron Emissions","title":"Synchrotron Radiation","ref":"/boltzmanncollisionintegral/stable/synchrotron/#Synchrotron-Radiation","content":" Synchrotron Radiation The synchrotron module allows for the evaluation of the rate of change of photon population ( $\\partial_t f(p_1,\\cos\\theta_1)$ ) due to synchrotron emissions from a distribution ( $f(p_2,\\cos\\theta_2)$ ) charged particles, with mass  $m_2$  and charge  $q_2$ , in a uniform magnetic field of strength  $B$  aligned with the axis of symmetry. The rate of change of photon distribution function is given by: \\[\\left(\\frac{\\partial f(\\boldsymbol{p}_1)}{\\partial t}\\right)_{Sync}=\\frac{Z}{B}\\frac{3c^5\\sigma_Tm_e^5}{4\\pi\\hbar^3\\mu_0e^3}\\int\\mathrm{d}^3\\boldsymbol{p}_2\\frac{1}{p_1p^0_2}\\left[\\left(\\frac{p^0_2\\cos\\theta_1-p_2\\cos\\theta_2\\cos\\theta_1}{\\sin\\theta_1}\\right)^2J_{\\omega/\\omega_0}(x)^2+(p_2\\sin\\theta_2)^2 J'_{\\omega/\\omega_0}(x)^2\\right]f(\\boldsymbol{p}_2).\\] where  $J$  are the Bessel functions ( $J'$  refer to the derivative with respect to the argument),  $\\frac{\\omega}{\\omega_0}=\\frac{m_e^2c^2p_1}{Z\\hbar eB}\\left(p^0_2-p_1\\cos\\theta_1\\cos\\theta_2\\right)$  and  $x=\\frac{\\omega}{\\omega_0}=\\frac{m_e^2c^2p_1}{Z\\hbar eB}p_1p_2\\sin\\theta_1\\sin\\theta_2$ .  $Z$  and  $\\mu$  are the normalised charge and mass of the emitting particle, normalised by the fundamental charge and electron mass respectively, all other constants have their standard (SI) values. Making the standard set of assumptions laid out in  BoltzmannCollisionIntegral.jl  this can be re-written in the form \\[\\left(\\frac{\\partial f_{1,ij}}{\\partial t}\\right)_{sync}=S_{ijkl}f_{2,kl}\\] with  \\[S_{ijkl}=\\frac{2\\pi}{\\Delta p_i\\Delta u_j}\\int_{\\Delta p_i\\Delta u_j}p_1^2\\mathrm{d}p_1\\mathrm{d}u_1 \\int \\mathrm{d}p_2\\mathrm{d}u_2~\\left|\\frac{Z}{B}\\frac{3c^5\\sigma_Tm_e^5}{4\\pi\\hbar^3\\mu_0e^3}\\right|\\frac{1}{p_1p^0_2}\\left[\\left(\\frac{p^0_2 u_1-p_2u_2u_1}{\\sqrt{1-u^2_1}}\\right)^2J_{\\omega/\\omega_0}(x)^2+p_1^2(1-u_2^2) J'_{\\omega/\\omega_0}(x)^2\\right]\\] where  $u=\\cos\\theta$ . Note Evaluation is normalised by  $c\\sigma_T$  to match the normalisation of the binary collision integral. The values of  $S_{ijkl}$  are then evaluated using a Monte Carlo method. To improve accuracy when  $\\omega/\\omega_0\\ge 10^3$ , the following approximation of the Bessel functions are made:  \\[J_n(x)\\approx\\frac{1}{\\pi\\sqrt{3}}\\left(1-\\frac{x^2}{n^2}\\right)^{1/2}K_{1/3}\\left(\\frac{n}{3}\\left(1-\\frac{x^2}{n^2}\\right)^{3/2}\\right),\\] \\[J'_n(x)\\approx\\frac{1}{\\pi\\sqrt{3}}\\left(1-\\frac{x^2}{n^2}\\right)K_{2/3}\\left(\\frac{n}{3}\\left(1-\\frac{x^2}{n^2}\\right)^{3/2}\\right).\\]"}]