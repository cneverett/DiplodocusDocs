<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/'</script><script charset="utf-8" src="../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Internal Functions · BoltzmannCollisionIntegral.jl</title><meta content="Internal Functions · BoltzmannCollisionIntegral.jl" name="title"/><meta content="Internal Functions · BoltzmannCollisionIntegral.jl" property="og:title"/><meta content="Internal Functions · BoltzmannCollisionIntegral.jl" property="twitter:title"/><meta content="Documentation for BoltzmannCollisionIntegral.jl." name="description"/><meta content="Documentation for BoltzmannCollisionIntegral.jl." property="og:description"/><meta content="Documentation for BoltzmannCollisionIntegral.jl." property="twitter:description"/><script data-outdated-warner="" src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="catppuccin-mocha" href="../assets/themes/catppuccin-mocha.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-macchiato" href="../assets/themes/catppuccin-macchiato.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-frappe" href="../assets/themes/catppuccin-frappe.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-latte" href="../assets/themes/catppuccin-latte.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="nothing/boltzmanncollisionintegral/stable/internalfunctions/" rel="canonical"/><link href="../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../diplodocusdocs/">Home</a><a class="nav-link active nav-item" href="../../">BoltzmannCollisionIntegral.jl</a><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="BoltzmannCollisionIntegral.jl logo" class="docs-light-only" src="../assets/logo.svg"/><img alt="BoltzmannCollisionIntegral.jl logo" class="docs-dark-only" src="../assets/logo-dark.svg"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BoltzmannCollisionIntegral.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quickstart/">Getting Started</a></li><li><a class="tocitem" href="../crosssections/">Cross Sections</a></li><li><a class="tocitem" href="../synchrotron/">Synchrotron Emissions</a></li><li class="is-active"><a class="tocitem" href="">Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Internal Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Internal Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/main/docs/src/internalfunctions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" href="javascript:;" id="documenter-article-toggle-button" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}" id="BoltzmannCollisionIntegral.DoesConserve-NTuple{5, Any}"><code>BoltzmannCollisionIntegral.DoesConserve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoesConserve(SMatrix3,SMatrix4,TMatrix1,TMatrix2,Parameters)</code></pre><p>Function prints the ratio of the sum of the S and T matricies and their differences, for all interaction paths, as to check number and energy conservation for a particular interaction. Arguments are as outputted by the <code>fload_All</code> function. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DataReading.jl#L193-L197" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float64, Float64, Float64}" id="BoltzmannCollisionIntegral.InvarientFlux-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFlux(s,mu12,mu22)</code></pre><p>returns the value of the invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L246-L250" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float64, Float64, Float64}" id="BoltzmannCollisionIntegral.InvarientFlux2-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFlux2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFlux2(s,mass12,mass22)</code></pre><p>returns the value of the squared invarient flux with 's' mandelstram variable and masses 'mass1' and 'mass2'</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L271-L275" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float64, Float64, Float64}" id="BoltzmannCollisionIntegral.InvarientFlux2Small-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFlux2Small</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFluxSmall(sSmol,mass12,mass22)</code></pre><p>returns the value of the squared invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L283-L287" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float64, Float64, Float64}" id="BoltzmannCollisionIntegral.InvarientFluxSmall-Tuple{Float64, Float64, Float64}"><code>BoltzmannCollisionIntegral.InvarientFluxSmall</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InvarientFluxSmall(sSmol,mu12,mu22)</code></pre><p>returns the value of the invarient flux with smalled 's' mandelstram variable (sSmol = s - (m1+m2)^2)</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L258-L262" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}" id="BoltzmannCollisionIntegral.Momentum3Value!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.Momentum3Value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum3Value!(p3v,p3pv,p1v,p2v)</code></pre><p>Takes set of random initial particle states 'p1v' and 'p2v' and random output states angles 'p3v[2:3]' and modifies outputs 'p3v' and 'p3pv' values with calculated output momentum and corrects angles if momentum is negative. Function also returns a two bools 'p3<em>physical' and 'p3p</em>physical' indicating if p3 and p3p are physical momentum states given the inputs.  Function also returns a Int 'NumStates' indicating the number of valid output states found.</p><p>Requrires normalised masses (mu1,mu2,mu3,mu4) to be defined in advance in Init.jl as const.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mu1 = 1836.1528e0
julia&gt; mu2 = 1836.1528e0
julia&gt; mu3 = 1836.1528e0
julia&gt; mu4 = 1836.1528e0
julia&gt; p1v = [1e0, 0.5e0, 1.8e0]
julia&gt; p2v = [2e0, 0.2e0, 0.7e0]
julia&gt; p3v = [0e0, 0.3e0, 0.7e0]
julia&gt; p3pv = zeros(Float64,3)
julia&gt; p3pv .= p3v
julia&gt; Momentum3Value!(p3v,p3pv,p1v,p2v,mu1,mu2,mu3,mu4)
(true,true,2)
julia&gt; p3v
 3-element Vector{Float64}:
 2.04505
 0.3
 0.7
julia&gt; p3pv
 3-element Vector{Float64}
 0.691423
 -0.3
 1.7</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/Momentum3Values.jl#L2-L35" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}" id="BoltzmannCollisionIntegral.PhaseSpaceFactors1!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Bool}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors1!(SMatrix3,SMatrix4,TMatrix,t3val,t4val,p1val,t1val,p2val,t2val,Indeistinguishable_12)</code></pre><p>Applies phase space volume element factors for 'SMatrix' and 'TMatrix' terms in order to correctly apply 'STSymmetry' corrections. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/PhaseSpaceFactors.jl#L1-L5" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{Float64, 4}, Vararg{Vector{Float64}, 8}}" id="BoltzmannCollisionIntegral.PhaseSpaceFactors2!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{Float64, 4}, Vararg{Vector{Float64}, 8}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactors2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactors2!(SMatrix3,SMatrix4,TMatrix,p3val,t3val,p4val,t4val,p1val,t1val,p2val,t2val)</code></pre><p>To follow 'PhaseSpaceFactors1' and 'STSymmetry'. Corrects phase space factors on 'SMatrix' and 'TMatrix' for use in kinetic codes. Assumes f(x,p,μ)= constant</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/PhaseSpaceFactors.jl#L33-L38" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}" id="BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!-Tuple{Array{Float64, 4}, Vararg{Vector{Float64}, 4}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactorsSync1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactorsSync1!(SMatrix,p1val,t1val,p2val,t2val)</code></pre><p>Applies phase space volume element factors for 'SMatrix' terms in order to correctly apply 'SyncSymmetry' corrections. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SyncPhaseSpaceFactors.jl#L1-L5" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}" id="BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!-Tuple{Array{Float64, 4}, Vector{Float64}, Vector{Float64}}"><code>BoltzmannCollisionIntegral.PhaseSpaceFactorsSync2!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhaseSpaceFactorsSync2!(SMatrix,p1val,t1val)</code></pre><p>To follow 'PhaseSpaceFactorsSync1' and 'SyncSymmetry'. Correct phase spcae factors on 'SMatrix' for use in kinetic codes. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SyncPhaseSpaceFactors.jl#L15-L19" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}" id="BoltzmannCollisionIntegral.RPointLogMomentum!-Tuple{Vector{Float64}, Float64, Float64, Int64}"><code>BoltzmannCollisionIntegral.RPointLogMomentum!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointLogMomentum!(pu,pl,pv,num)</code></pre><p>Edits the first element of <code>pv</code> with a random real-space momentum value between <span>$10^{pl}$</span> and <span>$10^{pu}$</span>. This sample is chosen by first randomly picking a momentum bin in the range <code>1:num</code> and then uniformly sampling a momentum point in real-space (rather than log10 space) between pl and pu which are the momentum values at start and end of that bin. Sampling is done such there will be a constant number of points per momentum-space volume. As the momentum space between <span>$10^{pl}$</span> and <span>$10^{pu}$</span> it is a spherical shell hence the correct sampling is <span>$p = (U*(10^{pu})^3+(1-U)*(10^{pl})^3)^{1/3}$</span> with uniform <span>$U ∈ [0~~1]$</span>.</p><p>Assumes <span>$f(x,p,μ)=f(x,\vec{p})*(2πp^2)=const$</span> in bin, therefore momentum space volume element is <span>$\mathrm{d}p$</span> and as such uniform sampling corresponds to <span>$U*10^{u}+(1-U)*10^{l}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p><p>If instead <span>$f(x,\vec{p})=const$</span> in bin, momentum space volume element is <span>$p^2 \mathrm{d}p$</span> and uniform sampling corresponds to <span>$(10^pu)*\sqrt[3]{U+(1-U)*10^{3pl-3pu}}$</span> where <span>$U$</span> is a uniform random number between 0 and 1.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/RandomPoints.jl#L5-L13" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}" id="BoltzmannCollisionIntegral.RPointSphereCosTheta!-Tuple{Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereCosTheta!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereTheta!()</code></pre><p>Assigns the second (cos(theta)) element of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta). </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/RandomPoints.jl#L47-L51" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}" id="BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!-Tuple{Vector{Float64}}"><code>BoltzmannCollisionIntegral.RPointSphereCosThetaPhi!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RPointSphereThetaPhi!()</code></pre><p>Assigns the second (cos(theta)) and third (phi) elements of 'a' with a randomly, uniformly sampled values of spherical angles cos(theta) and phi (phi normalised by pi). </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/RandomPoints.jl#L28-L32" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}" id="BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Any, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarloAxi_MultiThread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STMonteCarloAxi_MultiThread!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,t3MinMax,p4Max,t4MinMax,sigma,dsigmadt,Parameters,numTiterPerThread,numSiterPerThread)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal3::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;34 interaction</li><li><code>SAtotal4::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;43 interaction</li><li><code>TAtotal::Array{Float64,4}</code> : Array of stored integration totals for T matrix</li><li><code>SAtally3::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;34 interaction</li><li><code>SAtally4::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;43 interaction</li><li><code>TAtally::Array{UInt32,4}</code> : Array of stored integration tallies for T matrix</li><li><code>p3Max::Array{Float64,5}</code> : Array of maximum momentum values for species 3</li><li><code>t3MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 3</li><li><code>p4Max::Array{Float64,5}</code> : Array of maximum momentum values for species 4</li><li><code>t4MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 4</li><li><code>sigma::Function</code> : Cross section function for the interaction</li><li><code>dsigmadt::Function</code> : Differential cross section function for the interaction</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numTiterPerThread::Int64</code> : Number of T iterations per thread</li><li><code>numSiterPerThread::Int64</code> : Number of S iterations per thread</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Set up worker threads</li><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3,4)</li><li>RandomPointMomentum for p ( species 1,2 only)</li></ul></li><li>Take random points (t3,h3,p1,p2,t1,t2,h1,h2) and calculate valid p3 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Take random points (t4,h3,p1,p2,t1,t2,h1,h2) and calculate valid p4 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Update global S and T arrays with locks to prevent data races</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/MultiThread/STMonteCarlo_MultiThread.jl#L6-L39" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}" id="BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Array{UInt32, 5}, Array{UInt32, 5}, Array{UInt32, 4}, Array{Float64, 5}, Array{Float64, 5}, Array{Float64, 6}, Array{Float64, 6}, Function, Function, Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Vararg{Int64, 5}}, Int64, Int64}"><code>BoltzmannCollisionIntegral.STMonteCarloAxi_Serial!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STMonteCarloAxi_Serial!(SAtotal3,SAtotal4,TAtotal,SAtally3,SAtally4,TAtally,p3Max,p4Max,t3MinMax,t4MinMax,sigma,dsigmadt,Parameters,numTiter,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal3::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;34 interaction</li><li><code>SAtotal4::Array{Float64,6}</code> : Array of stored integration totals for S matrix for 12-&gt;43 interaction</li><li><code>TAtotal::Array{Float64,4}</code> : Array of stored integration totals for T matrix</li><li><code>SAtally3::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;34 interaction</li><li><code>SAtally4::Array{UInt32,5}</code> : Array of stored integration tallies for S matrix for 12-&gt;43 interaction</li><li><code>TAtally::Array{UInt32,4}</code> : Array of stored integration tallies for T matrix</li><li><code>p3Max::Array{Float64,5}</code> : Array of maximum momentum values for species 3</li><li><code>t3MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 3</li><li><code>p4Max::Array{Float64,5}</code> : Array of maximum momentum values for species 4</li><li><code>t4MinMax::Array{Float64,6}</code> : Array of minimum and maximum theta values for species 4</li><li><code>sigma::Function</code> : Cross section function for the interaction</li><li><code>dsigmadt::Function</code> : Differential cross section function for the interaction</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Float64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numTiter::Int64</code> : Number of T iterations</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,TAtotal,SAtally,TAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta and phi (for species 1,2,3,4)</li><li>RandomPointMomentum for p ( species 1,2 only)</li></ul></li><li>Take random points (t3,h3,p1,p2,t1,t2,h1,h2) and calculate valid p3 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li><li>Take random points (t4,h3,p1,p2,t1,t2,h1,h2) and calculate valid p4 point/points </li><li>Find position in local S and T arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Serial/STMonteCarlo_Serial.jl#L6-L37" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Float64, Float64}" id="BoltzmannCollisionIntegral.STSymmetry!-Tuple{Array{Float64, 6}, Array{Float64, 6}, Array{Float64, 4}, Float64, Float64}"><code>BoltzmannCollisionIntegral.STSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">STSymmetry!(SMatrix3,SMatrix4,TMatrix,t3val,mu1,mu2)</code></pre><p>To follow 'PhaseSpaceFactors1'. Physical nature of binary interaction has certain symmetries. 'STSymmetry' uses these symmetries to improve MC sampling of 'SMatrix' and 'TMatrix'.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/PhaseSpaceFactors.jl#L84-L88" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" id="BoltzmannCollisionIntegral.SValue3-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.SValue3</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SValue3(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p3v</code> and differential cross section <code>dsigmadt</code> based on particle selection 12-&gt;34.   Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L66-L71" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" id="BoltzmannCollisionIntegral.SValue4-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.SValue4</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SValue4(p3v,p1v,p2v,dsigmadt,mu1,mu2,mu3,mu4)</code></pre><p>Returns <code>Sval</code> from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and final state <code>p4v</code> and differential cross section <code>dsigmadt</code> based on particle selection 12-&gt;34.   Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L156-L161" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}" id="BoltzmannCollisionIntegral.SpectraEvaluateMultiThread-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateMultiThread(userInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a multi-threaded environment. The function will run the Monte Carlo integration in parallel across the number of threads specified in the global variable nThreads. The function will then calculate the S and T matricies and save the results to a file.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/MultiThread/STIntegration_MultiThread.jl#L8-L12" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}" id="BoltzmannCollisionIntegral.SpectraEvaluateSerial-Tuple{Tuple{String, String, String, String, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, String, String}}"><code>BoltzmannCollisionIntegral.SpectraEvaluateSerial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpectraEvaluateSerial(userInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S and T arrays in a serial environment. The function will run the Monte Carlo integration in serial and then calculate the S and T matricies and save the results to a file.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Serial/STIntegration_Serial.jl#L3-L7" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Any}" id="BoltzmannCollisionIntegral.SyncEvaluateMultiThread-Tuple{Any}"><code>BoltzmannCollisionIntegral.SyncEvaluateMultiThread</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncEvaluateMultiThread!(userSyncInputMultiThread)</code></pre><p>Function to run the Monte Carlo integration of the S array in a serial enviroment. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/MultiThread/SyncIntegration_MultiThread.jl#L1-L5" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Any}" id="BoltzmannCollisionIntegral.SyncEvaluateSerial-Tuple{Any}"><code>BoltzmannCollisionIntegral.SyncEvaluateSerial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncEvaluateSerial!(userSyncInputSerial)</code></pre><p>Function to run the Monte Carlo integration of the S array in a serial enviroment. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Serial/SyncIntegration_Serial.jl#L1-L5" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}" id="BoltzmannCollisionIntegral.SyncKernel-NTuple{5, Any}"><code>BoltzmannCollisionIntegral.SyncKernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncKernel(p1v,p2v,m2,z2,B)</code></pre><p>Returns the emission rate for a single photon <span>$p1v$</span> state emitted by a charged particle in state <span>$p2v$</span> with charge <span>$z2$</span> relative to the fundamental charge and mass <span>$m2$</span> relative to the mass of the electron, in a unifrom magnetic field <span>$B$</span>.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SynchrotronKernel.jl#L1-L5" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64, Int64}" id="BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Any, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64, Int64}"><code>BoltzmannCollisionIntegral.SyncMonteCarloAxi_MultiThread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncMonteCarloAxi_MultiThread!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float64,4}</code> : Array of stored integration totals for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>SAtally::Array{UInt32,4}</code> : Array of stored integration tallies for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>pMax::Array{Float64,3}</code> : Array of maximum momentum values for species 2</li><li><code>tMinMax::Array{Float64,3}</code> : Array of minimum and maximum theta values for species 2</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta (for species 1,2)</li><li>RandomPointMomentum for p ( species 1,2)</li></ul></li><li>Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity</li><li>Find position in S arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/MultiThread/SyncMonteCarlo_MultiThread.jl#L1-L21" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64}" id="BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!-Tuple{Array{Float64, 4}, Array{UInt32, 4}, Tuple{Float64, Float64, Float64, Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}, Int64, Int64}"><code>BoltzmannCollisionIntegral.SyncMonteCarloAxi_Serial!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncMonteCarloAxi_Serial!(SAtotal,SAtally,pMax,tMinMax,Parameters,numSiter)</code></pre><p><strong>Arguments</strong></p><ul><li><code>SAtotal::Array{Float64,4}</code> : Array of stored integration totals for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>SAtally::Array{UInt32,4}</code> : Array of stored integration tallies for S matrix for 2+B-&gt;2+B+1 interaction</li><li><code>pMax::Array{Float64,3}</code> : Array of maximum momentum values for species 2</li><li><code>tMinMax::Array{Float64,3}</code> : Array of minimum and maximum theta values for species 2</li><li><code>Parameters::Tuple{Float64,Float64,Float64,Int64,Float64,Float64,Int64,Int64,Int64}</code> : Tuple of parameters for the interaction</li><li><code>numSiter::Int64</code> : Number of S iterations</li></ul><p><strong>Output:</strong></p><ul><li>Argument arrays SAtotal,SAtally are mutated to include the results of the Monte Carlo Integration.</li></ul><p><strong>Calculation In Breif</strong></p><ul><li>Random Sample points in each of these domains<ul><li>RandomPointSphere for theta (for species 1,2)</li><li>RandomPointMomentum for p ( species 1,2)</li></ul></li><li>Take random points (p1,p2,t1,t2) and calculate Synchrotron emissivity</li><li>Find position in S arrays and allocated tallies and totals accordingly.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Serial/SyncMonteCarlo_Serial.jl#L1-L21" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}" id="BoltzmannCollisionIntegral.SyncSymmetry!-Tuple{Array{Float64, 4}}"><code>BoltzmannCollisionIntegral.SyncSymmetry!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncSymmetry!(SMatrix)</code></pre><p>To follow 'PhaseSpaceFactorsSync1'. Synchrotron emission has a symmetry with respect to cos(theta) -&gt; -cos(theta) for both initial particle and photon momenta.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SyncPhaseSpaceFactors.jl#L28-L32" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}" id="BoltzmannCollisionIntegral.TValue-Tuple{Vector{Float64}, Vector{Float64}, Function, Vararg{Float64, 4}}"><code>BoltzmannCollisionIntegral.TValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TValue(p1v,p2v,sigma,mu1,mu2)</code></pre><p>returns <code>Tval</code> with its Tval from MC integration based on initial momentum states <code>p1v</code> and <code>p2v</code> and cross section <code>sigma</code> based on particle selection. If initial state fails <code>sCheck</code>, i.e. cannot generate a physical output state, Tval is set to 0e0.  Assumes f(x,p,μ)=constant over bin</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/STValue.jl#L3-L8" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}" id="BoltzmannCollisionIntegral.deltaEVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaEVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaEVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of p grid boundries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float}</code> of average energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)
3-element Vector{Float64}:
 50.600693
 4951.15
 495001.16</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/UsefulGridValueFunctions.jl#L134-L147" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}" id="BoltzmannCollisionIntegral.deltaEkinVector-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaEkinVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaEkinVector(pr,mu)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of p grid boundries and the particle <code>mu</code> value (normalised mass) and returns a <code>num</code> long <code>Vector{Float}</code> of average kinetic energy values per grid cell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaEkinVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0], 1.0e0)
3-element Vector{Float64}:
     46.10069600605712
   4906.1506753523645
 494551.15128635924</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/UsefulGridValueFunctions.jl#L177-L190" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" id="BoltzmannCollisionIntegral.deltaVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.deltaVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deltaVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> quantitiy values (domain bounds) and returns a <code>num</code> long <code>Vector{Float}</code> of differeces (domain widths).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deltaVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])
3-element Vector{Float64}:
 9.0
 90.0
 900.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/UsefulGridValueFunctions.jl#L78-L91" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}" id="BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePhoElePho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePhoElePho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron-photon scattering (Compton) scattering. Berestetskii 1982 (86.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{d\sigma_{e\gamma\rightarrow e\gamma}}{dt}(s,t)=\frac{3}{(s-1)^2}\left[\left(\frac{1}{s-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{s-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{s-1}{u-1}+\frac{u-1}{s-1}\right)\right]\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 0 ∴ t = tSmol$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L176-L192" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}" id="BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_ElePosPhoPho(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.4). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{dσ_{e^+e^-\rightarrow\gamma\gamma}}{dt} = -\frac{3}{s(s-4)}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m2-m3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L66-L82" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}" id="BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_PhoPhoElePos(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for photon-photon annihilation to electron-positron pair. (Inverse proceess of electron positron annihilation to two photons). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\frac{dσ_{\gamma\gamma\rightarrow e^+e^-}}{dt} = -\frac{3}{s^2}\left(\left(\frac{1}{t-1}+\frac{1}{u-1}\right)^2+\left(\frac{1}{t-1}+\frac{1}{u-1}\right)-\frac{1}{4}\left(\frac{t-1}{u-1}+\frac{u-1}{t-1}\right)\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2 = 1 ∴ t = tSmol + 1$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2 = 1 ∴ u = uSmol + 1$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L122-L138" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}" id="BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.dsigmadt_SphSphSphSph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dsigmadt_SphSphSphSph(sSmol,sBig,tSmol,tBig,uSmol,uBig)</code></pre><p>returns the differential cross section for the binary interaction of hard spheres with normalised masses <span>$m_1,m_2,m_3,m_4=m_{\text{Sph}}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[\frac{dσ}{dt} = \frac{1}{s-4m_{\text{Sph}}^2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2=4m_{\text{Sph}}^2$</span></li><li><code>tSmol::Float64</code> : <span>$t - tBig$</span></li><li><code>tBig::Float64</code> : <span>$(m_3-m_1)^2=0$</span></li><li><code>uSmol::Float64</code> : <span>$u - uBig$</span></li><li><code>uBig::Float64</code> : <span>$(m_2-m_3)^2=0$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L12-L28" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.fload_All-Tuple{String, String}" id="BoltzmannCollisionIntegral.fload_All-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_All(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Run_Parameters,SAtot3,SAtot4,TAtot,SAtal3,SAtal4,TAtal,SMatrix3,SMatrix4,TMatrix1,TMatrix2,p3Max,p4Max,t3MinMax,t4MinMax,SConv3,SConv4,TConv) = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot3</code> : A 6D matrix totalling all the emission spectrum values sampled for 12-&gt;34 interaction.</li><li><code>Stot4</code> : A 6D matrix totalling all the emission spectrum values sampled for 12-&gt;43 interaction.</li><li><code>Ttot</code> : A 4D matrix totalling all the absorption spectrum values sampled.</li><li><code>Stal3</code> : A 5D matrix of tallies of the number of emission spectrum values sampled for 12-&gt;34 interaction.</li><li><code>Stal4</code> : A 5D matrix of tallies of the number of emission spectrum values sampled for 12-&gt;43 interaction.</li><li><code>Ttal</code> : A 4D matrix of tallies of the number of absorption spectrum values sampled.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction i.e. by permutation of TMatrix1 and correct application of phase space factors if species 1 != species 2.</li><li><code>p3Max</code> : The maximum value of the momentum space variable p3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>t3MinMax</code> : The minimum and maximum values of the momentum space variable t3 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>p4Max</code> : The maximum value of the momentum space variable p4 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>t4MinMax</code> : The minimum and maximum values of the momentum space variable t4 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv3</code> : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given <code>Run_Parameters</code> for 12-&gt;34 interaction.</li><li><code>SConv4</code> : A 6D matrix of the convergence of the emission spectrum compared to the previous run with given <code>Run_Parameters</code> for 12-&gt;43 interaction.</li><li><code>TConv</code> : A 4D matrix of the convergence of the absorption spectrum compared to the previous run with given <code>Run_Parameters</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DataReading.jl#L1-L30" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}" id="BoltzmannCollisionIntegral.fload_All_Sync-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_All_Sync</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_All_Sync(fileLocation,fileName)</code></pre><p>Loads all the data stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    (Run_Parameters,SAtot,SAtal,SMatrix,#=pMax,tMinMax,=#SConv) = fload_All_Sync(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>Stot</code> : A 4D matrix totalling all the synchrotron emission spectrum values</li><li><code>Stal</code> : A 4D matrix of tallies of the number of synchrotron emission spectrum values sampled</li><li><code>SMatrix</code> : A 4D matrix of the synchrotron emission spectrum.</li><li><code>pMax</code> : The maximum value of the momentum space variable p1 (photon mommentum) sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>tMinMax</code> : The minimum and maximum values of the momentum space variable t1 sampled for each bin. (Useful for correcting numerical diffusion)</li><li><code>SConv</code> : A 4D matrix of the convergence of the synchrotron emission spectrum compared to the previous run with given <code>Run_Parameters</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SyncDataReading.jl#L1-L18" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}" id="BoltzmannCollisionIntegral.fload_Matrix-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix(fileLocation,fileName)</code></pre><p>Loads just the S and T Matricies stored in <code>fileName</code> stored at <code>fileLocation</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matricies = fload_All(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction.</li></ul><p>If initial or final particles are identical then only one of the SMatricies or TMatricies will be returned for that state.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DataReading.jl#L70-L88" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}" id="BoltzmannCollisionIntegral.fload_Matrix_ISO-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_ISO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_ISO(fileLocation,fileName)</code></pre><p>Loads just the S and T Matricies stored in <code>fileName</code> stored at <code>fileLocation</code> first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D-&gt;6D with three dimensions having a size of 1)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matricies = fload_All_ISO(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>Run_Parameters</code> : A tuple of the parameters used in the evaluation.</li><li><code>SMatrix3</code> : A 6D matrix of the emission spectrum for 12-&gt;34 interaction.</li><li><code>SMatrix4</code> : A 6D matrix of the emission spectrum for 12-&gt;43 interaction.</li><li><code>TMatrix1</code> : A 4D matrix of the absorption spectrum for 12-&gt;34 interaction.</li><li><code>TMatrix2</code> : A 4D matrix of the absorption spectrum for 21-&gt;34 interaction.</li></ul><p>If initial or final particles are identical then only one of the SMatricies or TMatricies will be returned for that state.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DataReading.jl#L125-L143" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}" id="BoltzmannCollisionIntegral.fload_Matrix_Sync-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_Sync</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_Sync(fileLocation,fileName)</code></pre><p>Loads just the S and T Matricies stored in <code>fileName</code> stored at <code>fileLocation</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matricies = fload_Matrix_Sync(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>SMatrix</code> : A 4D matrix of the emission spectrum for Synchrotron.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SyncDataReading.jl#L44-L56" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}" id="BoltzmannCollisionIntegral.fload_Matrix_SyncISO-Tuple{String, String}"><code>BoltzmannCollisionIntegral.fload_Matrix_SyncISO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fload_Matrix_SyncISO(fileLocation,fileName)</code></pre><p>Loads just the S and T Matricies stored in <code>fileName</code> stored at <code>fileLocation</code> first converting them to an isotropic form by summing over angles. (The dimensions of the matricies stay the same i.e. 6D-&gt;6D with three dimensions having a size of 1)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">    Matricies = fload_Matrix_SyncISO(fileLocation,fileName);</code></pre><p>Returns a tuple of the data stored in the file. The fields are as follows:</p><ul><li><code>SMatrix</code> : A 4D matrix of the emission spectrum for Synchrotron.</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Synchrotron/Common/SyncDataReading.jl#L74-L86" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64}" id="BoltzmannCollisionIntegral.location-Tuple{Float64, Float64, Int64, Float64}"><code>BoltzmannCollisionIntegral.location</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location(u,l,num,val)</code></pre><p>Returns the index of the bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location(10e0,0e0,9,2e0)
2</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/Location.jl#L1-L11" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}" id="BoltzmannCollisionIntegral.location_p-Tuple{Float64, Float64, Int64, Float64}"><code>BoltzmannCollisionIntegral.location_p</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location_p(u,l,num,val)</code></pre><p>Returns the index of the momentum bin in which 'val' is contatined based on the 'num' of bins and their 'u' upper and 'l' lower bound including overflow and underflow possibilities. Overflow are assigned to num+1 while underflow are assigned to lowest bin i.e. 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_p(10e0,1e0,9,2e0)
2
julia&gt; location_p(10e0,1e0,9,11e0) # overflow
10
julia&gt; location_p(10e0,1e0,9,0.5e0) # underflow
1</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/Location.jl#L33-L47" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}" id="BoltzmannCollisionIntegral.location_t-Tuple{Int64, Float64}"><code>BoltzmannCollisionIntegral.location_t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">location_t(numt,val)</code></pre><p>Returns the index of the bin in which the costheta 'val' is contatined based on the 'numt' of bins. Bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; location_t(8,0.5e0)
6</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/Location.jl#L17-L27" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}" id="BoltzmannCollisionIntegral.meanVector-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.meanVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meanVector(valr)</code></pre><p>Inputs a <code>num+1</code> long <code>Vector{Float}</code> of domain bounds and returns a <code>num</code> long <code>Vector{Float}</code> of mean value in domain range.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; meanVector([1.0e0, 10.0e0, 100.0e0, 1000.0e0])
3-element Vector{Float64}:
 5.5
 55.0
 550.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/UsefulGridValueFunctions.jl#L106-L119" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.p4Vector!-NTuple{4, Vector{Float64}}" id="BoltzmannCollisionIntegral.p4Vector!-NTuple{4, Vector{Float64}}"><code>BoltzmannCollisionIntegral.p4Vector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p4Vector!(p4v,p3v,p1v,p2v)</code></pre><p>Returns the p4 vector (in standard form [p,cos(theta),phi/pi]) given the p1, p2 and p3 vectors using conservation of momentum.</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/Momentum3Values.jl#L209-L213" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.prange-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Union{Float32, Float64}" id="BoltzmannCollisionIntegral.prange-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Union{Float32, Float64}"><code>BoltzmannCollisionIntegral.prange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prange(pl,pu,nump)</code></pre><p>Returns a <code>nump+1</code> long <code>Vector{Float}</code> of p-space grid bounds NOT in Log10 space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prange(-5e0,4e0,9)
10-element Vector{Float64}:
 1.0e-5
 1.0e-4
 1.0e-3
 0.01
 0.1
 1.0
 10.0
 100.0
 1000.0
 10000.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/UsefulGridValueFunctions.jl#L24-L44" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}" id="BoltzmannCollisionIntegral.sCheck-NTuple{6, Float64}"><code>BoltzmannCollisionIntegral.sCheck</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sCheck(sSmol,sBig,mu3,mu4)</code></pre><p>Returns 'true' if 's' mandelstram generated from inital system state can generate a physical output state. </p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/MandelstramChecks.jl#L1-L5" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}" id="BoltzmannCollisionIntegral.sigma_ElePhoElePho-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_ElePhoElePho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_ElePhoElePho(sSmol,sBig)</code></pre><p>returns the total cross section for electron-photon (Compton) scattering. Berestetskii 1982 (86.16). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[\sigma_{e\gamma\rightarrow e\gamma}(s)=\frac{3}{4(s-1)}\left[(1-\frac{4}{\left(s-1\right)}-\frac{8m_e^4}{\left(s-1\right)^2})\log\left(s\right)+\frac{1}{2}+\frac{8}{s-1}-\frac{1}{2s^2}\right]\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 1 ∴ s = sSmol + 1$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L205-L217" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}" id="BoltzmannCollisionIntegral.sigma_ElePosPhoPho-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_ElePosPhoPho</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_ElePosPhoPho(sSmol,sBig)</code></pre><p>returns the total cross section for electron positron annihilation to two photons. Berestetskii 1982 (88.6). Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[σ_{e^+e^-\rightarrow\gamma\gamma} = \frac{3}{4s^2(s-4)}\left((s^2+4s-8)\log\left(\frac{\sqrt{s}+\sqrt{s-4}}{\sqrt{s}-\sqrt{s-4}}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 4 ∴ s = sSmol + 4$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L92-L104" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}" id="BoltzmannCollisionIntegral.sigma_PhoPhoElePos-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_PhoPhoElePos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_PhoPhoElePos(sSmol,sBig)</code></pre><p>returns the total cross section for photon-photon annihilation to electron-positron pair. Masses and momenta are normalised by the rest mass of the electron <span>$m_{\text{Ele}}$</span> and the cross section is normalised by <span>$σ_T$</span>.</p><p class="math-container">\[σ_{\gamma\gamma\rightarrow e^+e^-} = \frac{3}{2s^3}\left((s^2+4s-8)\log\left(\frac{\sqrt(s)+\sqrt(s-4)}{\sqrt(s)-\sqrt(s-4)}\right)-(s+4)\sqrt{s(s-4)}\right)\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : <span>$s - sBig$</span></li><li><code>sBig::Float64</code> : <span>$(m_1+m_2)^2 = 0 ∴ s = sSmol$</span></li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L147-L159" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}" id="BoltzmannCollisionIntegral.sigma_SphSphSphSph-Tuple{Float64, Float64}"><code>BoltzmannCollisionIntegral.sigma_SphSphSphSph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sigma_SphSphSphSph(sSmol,sBig)</code></pre><p>returns the total cross section for the binary interaction of hard spheres with normalised masses (wrt electron mass) <span>$m_1,m_2,m_3,m_4=m_\text{Sph}$</span>. Normalised by <span>$πR_{Sph}^2$</span>.</p><p class="math-container">\[σ = \frac{1}{2}\]</p><p><strong>Arguments</strong></p><ul><li><code>sSmol::Float64</code> : s - sBig</li><li><code>sBig::Float64</code> : (m1+m2)^2</li></ul></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/DifferentialCrossSectionFunctions.jl#L40-L52" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.trange-Tuple{Int64}" id="BoltzmannCollisionIntegral.trange-Tuple{Int64}"><code>BoltzmannCollisionIntegral.trange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trange(numt)</code></pre><p>Returns a <code>numt+1</code> long <code>Vector{Float}</code> of theta-space grid bounds in terms of cos(theta). Upper and lower bounds [tl tu] are defined as CONST in Init.jl as [-1 1], type returned is that of tl, tu.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trange(8)
9-element Vector{Float64}:
 -1.0
 -0.75
 -0.5
 -0.25
  0.0
  0.25
  0.5
  0.75
  1.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/UsefulGridValueFunctions.jl#L50-L70" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}" id="BoltzmannCollisionIntegral.vectorLocation-Tuple{Float64, Float64, Int64, Int64, Vector{Float64}}"><code>BoltzmannCollisionIntegral.vectorLocation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vectorLocation(pu,pl,nump,numt,vector)</code></pre><p>Returns a tuple of bin location for (log10momentum,cos(theta)) based on an input 'vector' and bounds 'u,l' of their domains and the 'num' of uniformly spaced bins. costheta bounds [tl tu] are defined as CONST in Init.jl</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vectorLocation(4e0,-5e0,9,8,[1e0,0.5e0,1.5e0]) (5,6)</p></div><a class="docs-sourcelink" href="https://github.com/cneverett/BoltzmannCollisionIntegral.jl/blob/d087a5ce37d9eb02d6277cccc6134a8c6385ea3b/src/Common/Location.jl#L55-L65" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../synchrotron/">« Synchrotron Emissions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 9 October 2024 10:18">Wednesday 9 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>